function [valid, orientation] = deterValOfLineUsingGaborResp(firstKPScore, secKPScore, respAnticlock1, respAnticlock2, ...
                                              respClock1, respClock2, alongLineResp1, alongLineResp2,...
                                              threshForRespRatioForValidSlotLine,...
                                              matchedGaborRespThreshSeparator, matchedGaborRespThreshBridge,...
                                              sumOfGaborRespTwoBridgesThreh,...
                                              sumOfGaborRespTwoSeparatorsThreh,...
                                              KPScoreSumThresh)
%this function determine whether a candiate slot line composed of two KPs
%is a valid line or not. The judgement is based on its Gabor responses
%test. If it is a valid line, the function also returns the "direction of
%the parking slot", whicn indicates the positions of the other two possible
%key points
%valid is a boolean value; true means the examined line is a highly
%possible slot line;
%orientation is 0 or 1; 0 means the slot orientation is anti-clockwise
%while 1 means that the slot orientation is clockwise. The orientation of
%the slot is with respect to the vector from the first KP pointing to the
%second KP
valid = false;
orientation = 0; %it should be noted that if valid is false, the orientation value does not make any sense.
if respAnticlock1 + respAnticlock2 > respClock1 + respClock2 &&...
   respAnticlock1 > 0 &&...
   respAnticlock2>0 &&...
   alongLineResp1 > respClock1 &&...
   alongLineResp2 > respClock2 &&...
   alongLineResp1 > 0 &&...
   alongLineResp2>0
           
           condition1 = (respAnticlock1-respClock1)/min(abs(respClock1), abs(respAnticlock1)) > threshForRespRatioForValidSlotLine;
           condition2 =  (respAnticlock2-respClock2)/min(abs(respClock2), abs(respAnticlock2)) > threshForRespRatioForValidSlotLine;
           condition3 = (alongLineResp1-respClock1)/min(abs(respClock1), abs(alongLineResp1)) > threshForRespRatioForValidSlotLine;
           condition4 = (alongLineResp2-respClock2)/min(abs(respClock2), abs(alongLineResp2)) > threshForRespRatioForValidSlotLine;
           condition5 = (firstKPScore > KPScoreSumThresh && secKPScore > KPScoreSumThresh) ||...
                                (firstKPScore>187.7 && secKPScore > 187.7 && firstKPScore + secKPScore>413);
                            
           
           if condition1 && condition2 && condition3 && condition4 && condition5 &&...
              respAnticlock1 > 21.5 && respAnticlock2 > 21.5 &&...
              respAnticlock1 + respAnticlock2 > 50 && ...
              alongLineResp1 + alongLineResp2 > 60 &&...
              alongLineResp1 > 25 && alongLineResp2>25
                  valid = true;
                  orientation = 0;
           elseif condition1 + condition2 + condition3 + condition4 + condition5 >=3
               if  respAnticlock1 > matchedGaborRespThreshSeparator &&...
                   respAnticlock2 > matchedGaborRespThreshSeparator &&...
                   alongLineResp1 > matchedGaborRespThreshBridge &&...
                   alongLineResp2 > matchedGaborRespThreshBridge &&...
                   alongLineResp1 +  alongLineResp2 > sumOfGaborRespTwoBridgesThreh &&...
                   respAnticlock1 +  respAnticlock2 > sumOfGaborRespTwoSeparatorsThreh &&...
                   firstKPScore + secKPScore > 351
                   
                   valid = true;
                   orientation = 0;
               end
           end
elseif respAnticlock1 +  respAnticlock2< respClock1 + respClock2 && ...
          respClock1 > 0 &&...
          respClock2>0 &&...
          alongLineResp1 > respAnticlock1 &&...
          alongLineResp2 > respAnticlock2 &&...
          alongLineResp1 > 0 &&...
          alongLineResp2>0
      
           condition1 = (respClock1-respAnticlock1)/min(abs(respClock1), abs(respAnticlock1)) > threshForRespRatioForValidSlotLine;
           condition2 =  (respClock2-respAnticlock2)/min(abs(respClock2), abs(respAnticlock2)) > threshForRespRatioForValidSlotLine;
           condition3 = (alongLineResp1-respAnticlock1)/min(abs(respAnticlock1), abs(alongLineResp1)) > threshForRespRatioForValidSlotLine;
           condition4 = (alongLineResp2-respAnticlock2)/min(abs(respAnticlock2), abs(alongLineResp2)) > threshForRespRatioForValidSlotLine;
           condition5 = (firstKPScore > KPScoreSumThresh && secKPScore > KPScoreSumThresh) ||...
                                (firstKPScore>187.7 && secKPScore > 187.7 && firstKPScore + secKPScore>413);
           
           if condition1 && condition2 && condition3 && condition4 && condition5 && ...
              respClock1 > 21.5 && respClock2 > 21.5 &&...
              respClock1 + respClock2 > 50 && ...
              alongLineResp1 + alongLineResp2 > 60 &&...
              alongLineResp1 > 25 && alongLineResp2>25
         
               valid = true;
               orientation = 1;
           elseif condition1 + condition2 + condition3 + condition4 + condition5 >=3
%                absCondition1 = respClock1 > matchedGaborRespThreshSeparator;
%                absCondition2 = respClock2 > matchedGaborRespThreshSeparator;
%                absCondition3 = alongLineResp1 > matchedGaborRespThreshBridge;
%                absCondition4 = alongLineResp2 > matchedGaborRespThreshBridge;
%                absCondition5 = alongLineResp1 +  alongLineResp2 > sumOfGaborRespTwoBridgesThreh;
%                absCondition6 = respClock1 +  respClock2 > sumOfGaborRespTwoSeparatorsThreh;
               if respClock1 > matchedGaborRespThreshSeparator &&...
                  respClock2 > matchedGaborRespThreshSeparator &&...
                  alongLineResp1 > matchedGaborRespThreshBridge &&...
                  alongLineResp2 > matchedGaborRespThreshBridge &&...
                  alongLineResp1 +  alongLineResp2 > sumOfGaborRespTwoBridgesThreh &&...
                  respClock1 +  respClock2 > sumOfGaborRespTwoSeparatorsThreh &&...
                  firstKPScore + secKPScore > 351
                   
                  valid = true;
                  orientation = 1;
               end
           end
 end